{"ast":null,"code":"import basex from '../../vendor/base-x.js';\nimport { coerce } from '../bytes.js';\n\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n\n}\n\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseDecode = baseDecode;\n  }\n\n  decode(text) {\n    if (typeof text === 'string') {\n      switch (text[0]) {\n        case this.prefix:\n          {\n            return this.baseDecode(text.slice(1));\n          }\n\n        default:\n          {\n            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n          }\n      }\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n\n  or(decoder) {\n    return or(this, decoder);\n  }\n\n}\n\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n\n  or(decoder) {\n    return or(this, decoder);\n  }\n\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n    }\n  }\n\n}\n\nexport const or = (left, right) => new ComposedDecoder({ ...(left.decoders || {\n    [left.prefix]: left\n  }),\n  ...(right.decoders || {\n    [right.prefix]: right\n  })\n});\nexport class Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n\n}\nexport const from = _ref => {\n  let {\n    name,\n    prefix,\n    encode,\n    decode\n  } = _ref;\n  return new Codec(name, prefix, encode, decode);\n};\nexport const baseX = _ref2 => {\n  let {\n    prefix,\n    name,\n    alphabet\n  } = _ref2;\n  const {\n    encode,\n    decode\n  } = basex(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => coerce(decode(text))\n  });\n};\n\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n\n  let end = string.length;\n\n  while (string[end - 1] === '=') {\n    --end;\n  }\n\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`);\n    }\n\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n\n  return out;\n};\n\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n\n  return out;\n};\n\nexport const rfc4648 = _ref3 => {\n  let {\n    name,\n    prefix,\n    bitsPerChar,\n    alphabet\n  } = _ref3;\n  return from({\n    prefix,\n    name,\n\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n\n  });\n};","map":{"version":3,"names":["basex","coerce","Encoder","constructor","name","prefix","baseEncode","encode","bytes","Uint8Array","Error","Decoder","baseDecode","decode","text","slice","JSON","stringify","or","decoder","ComposedDecoder","decoders","input","RangeError","Object","keys","left","right","Codec","encoder","from","baseX","alphabet","string","bitsPerChar","codes","i","length","end","out","bits","buffer","written","value","undefined","SyntaxError","data","pad","mask","rfc4648"],"sources":["/home/salex/Blockchain/Bootcamp-repositorio/32-DApp con React - Marketplace de NFTs/node_modules/multiformats/esm/src/bases/base.js"],"sourcesContent":["import basex from '../../vendor/base-x.js';\nimport { coerce } from '../bytes.js';\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${ this.prefix }${ this.baseEncode(bytes) }`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      switch (text[0]) {\n      case this.prefix: {\n          return this.baseDecode(text.slice(1));\n        }\n      default: {\n          throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);\n        }\n      }\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);\n    }\n  }\n}\nexport const or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nexport class Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nexport const from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);\nexport const baseX = ({prefix, name, alphabet}) => {\n  const {encode, decode} = basex(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => coerce(decode(text))\n  });\n};\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${ name } character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\nexport const rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n  });\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}