{"ast":null,"code":"import { Type } from '../token.js';\nimport { encodeCustom } from '../encode.js';\nimport { encodeErrPrefix } from '../common.js';\nimport { asU8A, fromString } from '../byte-utils.js';\n\nclass JSONEncoder extends Array {\n  constructor() {\n    super();\n    this.inRecursive = [];\n  }\n\n  prefix(buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1];\n\n    if (recurs) {\n      if (recurs.type === Type.array) {\n        recurs.elements++;\n\n        if (recurs.elements !== 1) {\n          buf.push([44]);\n        }\n      }\n\n      if (recurs.type === Type.map) {\n        recurs.elements++;\n\n        if (recurs.elements !== 1) {\n          if (recurs.elements % 2 === 1) {\n            buf.push([44]);\n          } else {\n            buf.push([58]);\n          }\n        }\n      }\n    }\n  }\n\n  [Type.uint.major](buf, token) {\n    this.prefix(buf);\n    const is = String(token.value);\n    const isa = [];\n\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n    }\n\n    buf.push(isa);\n  }\n\n  [Type.negint.major](buf, token) {\n    this[Type.uint.major](buf, token);\n  }\n\n  [Type.bytes.major](_buf, _token) {\n    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);\n  }\n\n  [Type.string.major](buf, token) {\n    this.prefix(buf);\n    const byts = fromString(JSON.stringify(token.value));\n    buf.push(byts.length > 32 ? asU8A(byts) : byts);\n  }\n\n  [Type.array.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.array,\n      elements: 0\n    });\n    buf.push([91]);\n  }\n\n  [Type.map.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.map,\n      elements: 0\n    });\n    buf.push([123]);\n  }\n\n  [Type.tag.major](_buf, _token) {}\n\n  [Type.float.major](buf, token) {\n    if (token.type.name === 'break') {\n      const recurs = this.inRecursive.pop();\n\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          buf.push([93]);\n        } else if (recurs.type === Type.map) {\n          buf.push([125]);\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!');\n        }\n\n        return;\n      }\n\n      throw new Error('Unexpected break; this should not happen!');\n    }\n\n    if (token.value === undefined) {\n      throw new Error(`${encodeErrPrefix} unsupported type: undefined`);\n    }\n\n    this.prefix(buf);\n\n    if (token.type.name === 'true') {\n      buf.push([116, 114, 117, 101]);\n      return;\n    } else if (token.type.name === 'false') {\n      buf.push([102, 97, 108, 115, 101]);\n      return;\n    } else if (token.type.name === 'null') {\n      buf.push([110, 117, 108, 108]);\n      return;\n    }\n\n    const is = String(token.value);\n    const isa = [];\n    let dp = false;\n\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {\n        dp = true;\n      }\n    }\n\n    if (!dp) {\n      isa.push(46);\n      isa.push(48);\n    }\n\n    buf.push(isa);\n  }\n\n}\n\nfunction mapSorter(e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${encodeErrPrefix} complex map keys are not supported`);\n  }\n\n  const keyToken1 = e1[0];\n  const keyToken2 = e2[0];\n\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);\n  }\n\n  if (keyToken1 < keyToken2) {\n    return -1;\n  }\n\n  if (keyToken1 > keyToken2) {\n    return 1;\n  }\n\n  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`);\n}\n\nconst defaultEncodeOptions = {\n  addBreakTokens: true,\n  mapSorter\n};\n\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, new JSONEncoder(), options);\n}\n\nexport { encode };","map":{"version":3,"names":["Type","encodeCustom","encodeErrPrefix","asU8A","fromString","JSONEncoder","Array","constructor","inRecursive","prefix","buf","recurs","length","type","array","elements","push","map","uint","major","token","is","String","value","isa","i","charCodeAt","negint","bytes","_buf","_token","Error","string","byts","JSON","stringify","tag","float","name","pop","undefined","dp","mapSorter","e1","e2","isArray","keyToken1","keyToken2","defaultEncodeOptions","addBreakTokens","encode","data","options","Object","assign"],"sources":["/home/salex/Blockchain/Bootcamp-repositorio/32-DApp con React - Marketplace de NFTs/node_modules/cborg/esm/lib/json/encode.js"],"sourcesContent":["import { Type } from '../token.js';\nimport { encodeCustom } from '../encode.js';\nimport { encodeErrPrefix } from '../common.js';\nimport {\n  asU8A,\n  fromString\n} from '../byte-utils.js';\nclass JSONEncoder extends Array {\n  constructor() {\n    super();\n    this.inRecursive = [];\n  }\n  prefix(buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1];\n    if (recurs) {\n      if (recurs.type === Type.array) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          buf.push([44]);\n        }\n      }\n      if (recurs.type === Type.map) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          if (recurs.elements % 2 === 1) {\n            buf.push([44]);\n          } else {\n            buf.push([58]);\n          }\n        }\n      }\n    }\n  }\n  [Type.uint.major](buf, token) {\n    this.prefix(buf);\n    const is = String(token.value);\n    const isa = [];\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n    }\n    buf.push(isa);\n  }\n  [Type.negint.major](buf, token) {\n    this[Type.uint.major](buf, token);\n  }\n  [Type.bytes.major](_buf, _token) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: Uint8Array`);\n  }\n  [Type.string.major](buf, token) {\n    this.prefix(buf);\n    const byts = fromString(JSON.stringify(token.value));\n    buf.push(byts.length > 32 ? asU8A(byts) : byts);\n  }\n  [Type.array.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.array,\n      elements: 0\n    });\n    buf.push([91]);\n  }\n  [Type.map.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.map,\n      elements: 0\n    });\n    buf.push([123]);\n  }\n  [Type.tag.major](_buf, _token) {\n  }\n  [Type.float.major](buf, token) {\n    if (token.type.name === 'break') {\n      const recurs = this.inRecursive.pop();\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          buf.push([93]);\n        } else if (recurs.type === Type.map) {\n          buf.push([125]);\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!');\n        }\n        return;\n      }\n      throw new Error('Unexpected break; this should not happen!');\n    }\n    if (token.value === undefined) {\n      throw new Error(`${ encodeErrPrefix } unsupported type: undefined`);\n    }\n    this.prefix(buf);\n    if (token.type.name === 'true') {\n      buf.push([\n        116,\n        114,\n        117,\n        101\n      ]);\n      return;\n    } else if (token.type.name === 'false') {\n      buf.push([\n        102,\n        97,\n        108,\n        115,\n        101\n      ]);\n      return;\n    } else if (token.type.name === 'null') {\n      buf.push([\n        110,\n        117,\n        108,\n        108\n      ]);\n      return;\n    }\n    const is = String(token.value);\n    const isa = [];\n    let dp = false;\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {\n        dp = true;\n      }\n    }\n    if (!dp) {\n      isa.push(46);\n      isa.push(48);\n    }\n    buf.push(isa);\n  }\n}\nfunction mapSorter(e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${ encodeErrPrefix } complex map keys are not supported`);\n  }\n  const keyToken1 = e1[0];\n  const keyToken2 = e2[0];\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(`${ encodeErrPrefix } non-string map keys are not supported`);\n  }\n  if (keyToken1 < keyToken2) {\n    return -1;\n  }\n  if (keyToken1 > keyToken2) {\n    return 1;\n  }\n  throw new Error(`${ encodeErrPrefix } unexpected duplicate map keys, this is not supported`);\n}\nconst defaultEncodeOptions = {\n  addBreakTokens: true,\n  mapSorter\n};\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, new JSONEncoder(), options);\n}\nexport {\n  encode\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}